# ğŸ“ˆ Plano de Desenvolvimento Individual (PDI) â€” Marcos

## ğŸ¯ Objetivo Geral
Elevar o nÃ­vel tÃ©cnico em desenvolvimento de software backend, com foco em Java Spring Boot, prÃ¡ticas avanÃ§adas de arquitetura, testes, qualidade de cÃ³digo e entrega contÃ­nua, tornando-se uma referÃªncia tÃ©cnica para soluÃ§Ãµes robustas e de alta qualidade.

---

## ğŸ— Objetivos EspecÃ­ficos

âœ… Aprimorar design de software:
- Dominar arquitetura hexagonal e DDD (Domain-Driven Design)
- Aplicar SOLID, Clean Code e Clean Architecture em projetos reais
- Usar padrÃµes de design avanÃ§ados (strategy, factory, decorator, chain of responsibility)

âœ… AvanÃ§ar em testes:
- Ampliar cobertura de testes unitÃ¡rios, integrados e de contrato
- Escrever testes automatizados com JUnit 5, Mockito, Testcontainers
- Adotar TDD (Test-Driven Development) em partes crÃ­ticas do cÃ³digo

âœ… Melhorar qualidade de cÃ³digo:
- Analisar e corrigir problemas apontados por SonarQube e SonarLint
- Implementar revisÃµes de cÃ³digo regulares focadas em padrÃµes e consistÃªncia
- Aplicar mÃ©tricas como cobertura de cÃ³digo, complexidade ciclomÃ¡tica e maintainability index

âœ… Aprimorar integraÃ§Ã£o e versionamento:
- Gerenciar versÃµes de APIs usando semantic versioning e OpenAPI
- Automatizar builds e testes com pipelines CI/CD (GitHub Actions, GitLab CI)
- Garantir rollback seguro e deploys confiÃ¡veis (blue/green, canary releases)

âœ… Monitorar performance e rastreabilidade:
- Usar APM (Application Performance Monitoring) para identificar gargalos
- Implementar logs estruturados, tracing distribuÃ­do e mÃ©tricas detalhadas
- Medir impacto de mudanÃ§as usando indicadores como latÃªncia e throughput

---

## ğŸ“… Plano Trimestral

### 1Âº Trimestre: Design e Arquitetura
- Estudar e aplicar arquitetura hexagonal + DDD em um mÃ³dulo real.
- Refatorar partes do cÃ³digo aplicando SOLID e Clean Code.
- Identificar pontos de acoplamento excessivo e redesenhar usando padrÃµes de design.

### 2Âº Trimestre: Qualidade e Testes
- Aumentar cobertura de testes unitÃ¡rios acima de 80% em componentes crÃ­ticos.
- Introduzir testes de contrato usando Spring Cloud Contract.
- Automatizar testes com Testcontainers para integraÃ§Ã£o com bancos e filas reais.

### 3Âº Trimestre: Performance e Entrega
- Configurar SonarQube no pipeline CI/CD e corrigir findings crÃ­ticos.
- Medir performance com APM (como New Relic, Elastic APM) e propor melhorias.
- Implementar deploy seguro com rollback automÃ¡tico e versionamento claro.

---

## ğŸ“š Fontes de Estudo

| Tema                          | Material Sugerido                                                                 |
|-------------------------------|----------------------------------------------------------------------------------|
| Arquitetura Hexagonal + DDD   | [Reflectoring.io Hexagonal](https://reflectoring.io/spring-hexagonal/)            |
| SOLID e Clean Architecture    | [Livro: Clean Architecture (Robert C. Martin)]                                     |
| PadrÃµes de Design AvanÃ§ados   | [Refactoring Guru](https://refactoring.guru/design-patterns)                      |
| Testes Automatizados          | [Spring Boot Testing Guide](https://spring.io/guides/gs/testing-web/)             |
| Testcontainers                | [Testcontainers Docs](https://www.testcontainers.org/)                            |
| API Versioning                | [Semantic Versioning](https://semver.org/)                                        |
| SonarQube                     | [SonarQube Docs](https://docs.sonarsource.com/)                                   |
| APM e Tracing                 | [Elastic APM](https://www.elastic.co/apm) / [OpenTelemetry](https://opentelemetry.io/) |

---

## ğŸ§ª MÃ©tricas e AvaliaÃ§Ã£o
- Cobertura de testes (%)
- Issues crÃ­ticas corrigidas no SonarQube
- ReduÃ§Ã£o de complexidade ciclomÃ¡tica
- NÃºmero de APIs versionadas corretamente
- Ganho de performance (latÃªncia, throughput)
- Pull requests revisadas e aprovadas com qualidade

---

## ğŸ›¡ Riscos e MitigaÃ§Ãµes
- **Falta de tempo** â†’ Reservar 4h/semana fixas para estudo e aplicaÃ§Ã£o.
- **Complexidade tÃ©cnica** â†’ Dividir aprendizado em entregas pequenas e incrementais.
- **MudanÃ§as de prioridade no projeto** â†’ Garantir alinhamento frequente com o gestor.

---

## ğŸ”š Resultado Esperado no Final do Ano
Marcos serÃ¡ capaz de projetar, desenvolver e entregar software backend de alta qualidade, com arquitetura sÃ³lida, testes avanÃ§ados, excelente performance e total domÃ­nio sobre prÃ¡ticas modernas de versionamento e integraÃ§Ã£o contÃ­nua.
